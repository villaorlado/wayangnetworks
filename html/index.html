
<html>
<!-- [...] -->
<style>
#sigma-container{
  top:0px;
  left:0px;
  width:100%;
  height:100%;
  position:absolute;
}

#explanation{
  position:absolute;
  top:10px;
right40px;
  width:300px;
  border:2px solid black;
  padding:10px;
  box-shadow: 10px 10px 10px grey;;
  background-color:white;
  display:none;
  z-index:3000;
}


</style>

<script src="sigma/sigma.js"></script>
<script src="sigma/plugins/sigma.parsers.gexf.min.js"></script>
<script
  src="https://code.jquery.com/jquery-3.1.1.min.js"
  integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
  crossorigin="anonymous">
</script>
<script>

sigma.classes.graph.addMethod('neighbors', function(nodeId) {
   var k,
       neighbors = {},
       index = this.allNeighborsIndex[nodeId] || {};

   for (k in index)
     neighbors[k] = this.nodesIndex[k];

   return neighbors;
 });

  sigma.parsers.gexf(
    'data/wayang.gexf',
    { // Here is the ID of the DOM element that
      // will contain the graph:
      container: 'sigma-container'
    },
    function(s) {
      // This function will be executed when the
      // graph is displayed, with "s" the related
      // sigma instance.
      s.graph.nodes().forEach(function(n) {
        n.originalColor = n.color;
      });
      s.graph.edges().forEach(function(e) {
        e.originalColor = e.color;
      });

      // When a node is clicked, we check for each node
      // if it is a neighbor of the clicked one. If not,
      // we set its color as grey, and else, it takes its
      // original color.
      // We do the same for the edges, and we only keep
      // edges that have both extremities colored.
      s.bind('clickNode', function(e) {
        var nodeId = e.data.node.id,
            toKeep = s.graph.neighbors(nodeId),
            explanation = "<b><a href='characterPages/" + e.data.node.label + ".html'>" + e.data.node.label + "</a></b>",
            linkedCharacters = [];
        toKeep[nodeId] = e.data.node;

        s.graph.nodes().forEach(function(n) {
          if (toKeep[n.id]){
            n.color = n.originalColor;
            linkedCharacters.push(n.id);
          }
          else{
            n.color = '#eee';
          }
        });

        //modularity_class, componentnumber, clustering, Triangles, newClusteringCoefficient, eigencentrality
        //explanation += JSON.stringify(e.data.node.attributes);

        //explanation += $.load("characterPages/" + e.data.node.label + ".txt");
        //$.get(("characterPages/" + e.data.node.label + ".txt"), function (data){alert(JSON.stringify(data));});

        $.ajax({url: "characterPages/" + e.data.node.label + ".txt", success: function(result){
        //  alert("a");
          explanation += result;
          explanation += "<p><br/>Degree: " + e.data.node.attributes.degree;
          explanation += "<br/>Weighted degree: " + e.data.node.attributes["weighted degree"];
          explanation += "<br/>Eccentricity: " + e.data.node.attributes.eccentricity;
          explanation += "<br/>Closness centrality: " + parseFloat(e.data.node.attributes.closnesscentrality).toFixed(2);
          explanation += "<br/>Betweeness centrality: " + e.data.node.attributes.betweenesscentrality.toFixed(2);
          explanation += "<br/>Clustering: " + e.data.node.attributes.clustering.toFixed(2);
          //explanation += "<br/>Linked to: " + (linkedCharacters.length -1 )  + " characters";
          $("#explanation").html(explanation);
          $("#explanation").show();
        }});

        s.graph.edges().forEach(function(e) {
          if (toKeep[e.source] && toKeep[e.target]){
            e.color = e.originalColor;
            //explanation += JSON.stringify(e);
            //explanation += e.source;
          }
          else{
            e.color = '#eee';
          }
          //if (toKeep[e.source] && toKeep[e.target])
        });



        // Since the data has been modified, we need to
        // call the refresh method to make the colors
        // update effective.
        s.refresh();
      });

      // When the stage is clicked, we just color each
      // node and edge with its original color.
      s.bind('clickStage', function(e) {
        s.graph.nodes().forEach(function(n) {
          n.color = n.originalColor;
        });

        s.graph.edges().forEach(function(e) {
          e.color = e.originalColor;
        });

        // Same as in the previous event:
        s.refresh();
      });
    }
  );
</script>
<div id="sigma-container"></div>
<div id="explanation"></div>
<!-- [...] -->
</html>
